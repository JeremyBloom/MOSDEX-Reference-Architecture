<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (13) on Mon Aug 08 15:55:32 PDT 2022 -->
<title>MsdxCplexModelingFactory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-08-08">
<meta name="description" content="declaration: package: io.github.JeremyBloom.mosdex2.modeling, class: MsdxCplexModelingFactory">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MsdxCplexModelingFactory.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.github.JeremyBloom.mosdex2.modeling</a></div>
<h1 title="Class MsdxCplexModelingFactory" class="title">Class MsdxCplexModelingFactory</h1>
</div>
<div class="contentContainer">
<div class="inheritance" title="Inheritance Tree">java.lang.Object
<div class="inheritance">io.github.JeremyBloom.mosdex2.modeling.MsdxCplexModelingFactory</div>
</div>
<section class="description">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
</dl>
<hr>
<pre>public class <span class="typeNameLabel">MsdxCplexModelingFactory</span>
extends java.lang.Object
implements <a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></pre>
<div class="block">This class implements the methods used to create solver-specific modeling objects 
 for IBM's CPLEX solver.<br>
 You need to have a licensed copy of IBM CPLEX in order to use this code.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Dr. Jeremy A. Bloom (jeremyblmca@gmail.com) Â©2019 Jeremy A. Bloom</dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<li class="blockList">
<section class="fieldSummary"><a id="field.summary">
<!--   -->
</a>
<h2>Field Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<td class="colFirst"><code>private <a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dataframeFactory">dataframeFactory</a></span></code></th>
<td class="colLast">
<div class="block">The factory that creates dataframes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#functionTable">functionTable</a></span></code></th>
<td class="colLast">
<div class="block">The function table is a mapping between the function names, established in the 
 FunctionCall object, and the function implementations as Java Functions.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected ilog.cplex.IloCplex</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#modeler">modeler</a></span></code></th>
<td class="colLast">
<div class="block">Creates CPLEX-specific modeling objects.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>private java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#modelName">modelName</a></span></code></th>
<td class="colLast">
<div class="block">The model name.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>private java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orientation">orientation</a></span></code></th>
<td class="colLast">
<div class="block">The orientation, either "Row" or "Column".</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected ilog.cplex.IloCplex</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#solver">solver</a></span></code></th>
<td class="colLast">
<div class="block">Calls the CPLEX solver (for CPLEX, the modeler and solver are the same object.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<li class="blockList">
<section class="constructorSummary"><a id="constructor.summary">
<!--   -->
</a>
<h2>Constructor Summary</h2>
<div class="memberSummary">
<table>
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<thead>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E(ilog.cplex.IloCplex,io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">MsdxCplexModelingFactory</a></span>&#8203;(ilog.cplex.IloCplex&nbsp;modeler,
<a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a>&nbsp;dataframeFactory)</code></th>
<td class="colLast">
<div class="block">Creates a new CPLEX factory instance.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(java.lang.String,java.lang.String)">add</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Adds (reduces) Term expressions across the columns (in row orientation) or
 rows (in column orientation).</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#attach()">attach</a></span>()</code></th>
<td class="colLast">
<div class="block">Attaches sum expressions to constraints and objectives in row orientation or
 to variables in column orientation.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">generate</a></span>&#8203;(<a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</code></th>
<td class="colLast">
<div class="block">Write a text representation of the model.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFunctionTable()">getFunctionTable</a></span>()</code></th>
<td class="colLast">
<div class="block">The function table is a mapping between the function names, established in the 
 FunctionCall object, and the function implementations as Java Functions.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getName()">getName</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initializeFunctionTable(io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">initializeFunctionTable</a></span>&#8203;(<a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a>&nbsp;dataframeFactory)</code></th>
<td class="colLast">
<div class="block">This method creates an initial set of function entries for the most common 
 solution information produced by a solver.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeConstraint(java.lang.String,java.lang.String)">makeConstraint</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific constraint object.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeObjective(java.lang.String,java.lang.String)">makeObjective</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific objective object.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeVariable(java.lang.String,java.lang.String)">makeVariable</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific variable object.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multiply(java.lang.String,java.lang.String)">multiply</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific expression object by computing a solver-specific
 product of a coefficient and one or two modeling objects.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orientation()">orientation</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retrieveSolution(java.lang.String)">retrieveSolution</a></span>&#8203;(java.lang.String&nbsp;tableClass)</code></th>
<td class="colLast">
<div class="block">This Operator is used in MsdxModel to retrieve the solution items from the
 solver.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">solve</a></span>&#8203;(<a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</code></th>
<td class="colLast">
<div class="block">Calls the solver, returns its status, and creates the solver results.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withName(java.lang.String)">withName</a></span>&#8203;(java.lang.String&nbsp;modelName)</code></th>
<td class="colLast">
<div class="block">Sets the name of the model created by this factory.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="inheritedList">
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a><code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></div>
<div class="inheritedList">
<h3>Methods inherited from interface&nbsp;io.github.JeremyBloom.mosdex2.modeling.<a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></h3>
<a id="methods.inherited.from.class.io.github.JeremyBloom.mosdex2.modeling.MsdxSolverModelingFactory">
<!--   -->
</a><code><a href="MsdxSolverModelingFactory.html#contraOrientation()">contraOrientation</a>, <a href="MsdxSolverModelingFactory.html#creationOrder()">creationOrder</a>, <a href="MsdxSolverModelingFactory.html#extractParameters(java.lang.String,java.lang.String,java.lang.String,io.github.JeremyBloom.mosdex2.MsdxContainer)">extractParameters</a>, <a href="MsdxSolverModelingFactory.html#generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,io.github.JeremyBloom.mosdex2.MsdxOutputDestination)">generate</a>, <a href="MsdxSolverModelingFactory.html#parameterDefaults(java.lang.String,java.lang.String)">parameterDefaults</a>, <a href="MsdxSolverModelingFactory.html#parameterFields(java.lang.String,java.lang.String)">parameterFields</a>, <a href="MsdxSolverModelingFactory.html#solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,io.github.JeremyBloom.mosdex2.MsdxOutputDestination)">solve</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<li class="blockList">
<section class="fieldDetails"><a id="field.detail">
<!--   -->
</a>
<h2>Field Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="dataframeFactory">dataframeFactory</a></h3>
<div class="memberSignature"><span class="modifiers">private</span>&nbsp;<span class="returnType"><a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a></span>&nbsp;<span class="memberName">dataframeFactory</span></div>
<div class="block">The factory that creates dataframes.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="orientation">orientation</a></h3>
<div class="memberSignature"><span class="modifiers">private final</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">orientation</span></div>
<div class="block">The orientation, either "Row" or "Column".
 This is a constant in each implementation, set in the constructor and 
 immutable thereafter.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="modeler">modeler</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">ilog.cplex.IloCplex</span>&nbsp;<span class="memberName">modeler</span></div>
<div class="block">Creates CPLEX-specific modeling objects.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="solver">solver</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">ilog.cplex.IloCplex</span>&nbsp;<span class="memberName">solver</span></div>
<div class="block">Calls the CPLEX solver (for CPLEX, the modeler and solver are the same object.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="modelName">modelName</a></h3>
<div class="memberSignature"><span class="modifiers">private</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">modelName</span></div>
<div class="block">The model name.</div>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="functionTable">functionTable</a></h3>
<div class="memberSignature"><span class="modifiers">protected</span>&nbsp;<span class="returnType">java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</span>&nbsp;<span class="memberName">functionTable</span></div>
<div class="block">The function table is a mapping between the function names, established in the 
 FunctionCall object, and the function implementations as Java Functions.
 The function table is created by the initializeFunctionTable method in this  
 this factory class.</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<li class="blockList">
<section class="constructorDetails"><a id="constructor.detail">
<!--   -->
</a>
<h2>Constructor Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="&lt;init&gt;(ilog.cplex.IloCplex,io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">MsdxCplexModelingFactory</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="memberName">MsdxCplexModelingFactory</span>&#8203;(<span class="arguments">ilog.cplex.IloCplex&nbsp;modeler,
<a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a>&nbsp;dataframeFactory)</span></div>
<div class="block">Creates a new CPLEX factory instance.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>modeler</code> - a CPLEX instance</dd>
<dd><code>dataframeFactory</code> - creates the Dataframes</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="getName()">getName</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">getName</span>()</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#getName()">getName</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the name of the model created by this factory; 
 you should create an instance field to hold the name</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="withName(java.lang.String)">withName</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></span>&nbsp;<span class="memberName">withName</span>&#8203;(<span class="arguments">java.lang.String&nbsp;modelName)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#withName(java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Sets the name of the model created by this factory.
 You should create a instance field to hold the name.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#withName(java.lang.String)">withName</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>modelName</code> - TODO</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>this factory</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="orientation()">orientation</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">orientation</span>()</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#orientation()">orientation</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the orientation, either "Row" or "Column".
 The orientation should be set in the constructor and 
 should be the same for all modeling objects created by the factory.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeVariable(java.lang.String,java.lang.String)">makeVariable</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">makeVariable</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#makeVariable(java.lang.String,java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Builds a solver-specific variable object.
 The underlying operator encapsulates all of the components required to build a variable object.
 <p>
 Performs the following transformation:
 <pre><code>
 [VARIABLE table parameters...] -&gt (makeVariable)  -&gt [solver variables...]
 </code></pre>
 Note that in the diagram above, the end point of each row represents a Span and 
 the transformation is denoted by the operator in parentheses.
 <p>
 Coding the makeVariable operator requires defining two components: the
 makeResultSchema method, which specifies the solver-specific variable class, 
 and the apply method, which creates the variable from the parameters.
 <p>
 This method is called by the MsdxModel.createVariable method as part of a two Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#makeVariable(java.lang.String,java.lang.String)">makeVariable</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters to a Container holding a solver-specific variable</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeConstraint(java.lang.String,java.lang.String)">makeConstraint</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">makeConstraint</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#makeConstraint(java.lang.String,java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Builds a solver-specific constraint object.
 The underlying operator encapsulates all of the components required to build a constraint object.
 <p>
 Performs the following transformation:
 <pre><code>
 [CONSTRAINT parameters...] -&gt (makeConstraint)  -&gt [solver constraints...]
 </code></pre>        
 Note that in the diagram above, the end point of each row represents a span and 
 the transformation is denoted by the operator in parentheses.
 <p>
 Coding the makeConstraint operator requires defining two components: the
 makeResultSchema method, which specifies the solver-specific constraint class, 
 and the apply method, which creates the constraint from the parameters.
 <p>
 This method is called by the MsdxModel.createConstraint method as part of a two Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#makeConstraint(java.lang.String,java.lang.String)">makeConstraint</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters to a Container holding a solver-specific constraint</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeObjective(java.lang.String,java.lang.String)">makeObjective</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">makeObjective</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#makeObjective(java.lang.String,java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Builds a solver-specific objective object.
 The underlying operator encapsulates all of the components required to build an objective object.
 <p>
 Performs the following transformation:
 <pre><code>
 [OBJECTIVE parameters...] -&gt (makeObjective)  -&gt [solver objectives...]
 </code></pre>        
 Note that in the diagram above, the end point of each row represents a span and 
 the transformation is denoted by the operator in parentheses.
 <p>
 Coding the makeObjective operator requires defining two components: the
 makeResultSchema method, which specifies the solver-specific objective class, 
 and the apply method, which creates the objective from the parameters.
 <p>
 This method is called by the MsdxModel.createObjective method as part of a two Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#makeObjective(java.lang.String,java.lang.String)">makeObjective</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters to a Container holding a solver-specific objective</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="multiply(java.lang.String,java.lang.String)">multiply</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">multiply</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#multiply(java.lang.String,java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Builds a solver-specific expression object by computing a solver-specific
 product of a coefficient and one or two modeling objects. The underlying
 operator encapsulates all of the components required to build a Term object.
 Called by a join operation which combines the Term parameters with the
 Variables in a Row orientation, where it creates either linear or quadratic
 terms, or with the Constraints and Objectives in a Column orientation, where
 only linear terms are allowed.
 <p>
 If the Term is of type LINEAR, the multiply operator is applied once for the
 product of a coefficient with a Variable; if the Term is of type QUADRATIC,
 it is applied following a standard merge join with the first Variable for the
 product of a coefficient with two Variables.
 <p>
 Performs the following transformation:<br>
 In Row Orientation - 
 <pre><code>
 [rowId, columnId, coefficient] {if LINEAR} (join and multiply) [columnId, solver variable ] -&gt 
 [rowId, columnId, solver expression(coefficient * variable object)]
 or 
 [rowId, columnId, coefficient] {if QUADRATIC} -&gt  (join) [columnId, solver variable ] -&gt 
 (join and multiply) [columnId2, solver variable2] -&gt [rowId, solver expression(coefficient * solver variable * solver variable2)] 
 </code></pre>
 In Column Orientation - 
 <pre><code>
 [columnId, rowId, coefficient] -&gt (join and multiply) [rowId, constraint or objective object] -&gt 
 [columnId, rowId, expression(coefficient)] 
 </code></pre>
 The multiply operator takes as its input arguments two Containers holding
 respectively the coefficient and modeling object, each also having the key (i.e. the column id or,
 less commonly the row id). It produces a result container holding the key
 and the expression object representing the product. (Note that in an optimization model, a product is
 not a number, but it is a solver-specific object that is usually an instance
 of an expression class).
 <p>
 Coding the multiply operator requires defining two components: the
 makeResultSchema method, which specifies the class of the product 
 expression, and the apply methods (onKeyMatch and noKeyMatch), which call
 the solver-specific method that computes the product.
 <p>
 This method is called by the MsdxModel.createTermsByRows and 
 MsdxModel.createTermsByColumns methods as part of a multi-Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#multiply(java.lang.String,java.lang.String)">multiply</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters and
         solver modeling object to a Container holding a solver-specific product expression</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="add(java.lang.String,java.lang.String)">add</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">add</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#add(java.lang.String,java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Adds (reduces) Term expressions across the columns (in row orientation) or
 rows (in column orientation). Called by a reduce method, it provides an operator 
 which invokes the solver-specific sum of terms. 
 It should throw UnsupportedOperationException for inapplicable kinds of modeling objects.
 <p>
 The add operator performs the following transformation: <br>
 For row orientation --
 <pre><code>
 [rowId, columnId, solver term] -&gt  (add across columnIds) [rowId, solver expression(sum)]
 </code></pre>
 For column orientation --
 <pre><code>
 [rowId, columnId, solver term] -&gt  (add across rowIds) [columnId, solver expression(sum)]
 </code></pre>
 The add operator takes as its input arguments two containers holding
 respectively the value field or fields representing the terms to be
 adjoined to the accumulation and the accumulation field (or fields) representing the sum
 expression, each also having the key (i.e. the row id or,
 less commonly the column id). The add operator is used to add the individual
 terms to the sum expression. It produces a result container holding the key
 and the accumulation objects. (Note that in an optimization model, a sum is
 not a number, but it is a solver-specific object that is usually an instance
 of an expression class representing a sum of terms).
 <p>
 Coding the add operator requires defining two components: the
 makeResultSchema method, which specifies the class(es) of the accumulation
 expression(s), and the apply methods (onKeyMatch and noKeyMatch), which call
 the solver-specific methods that computes the sum. The result schema merges 
 the value schema with the key and accumulation fields of the accumulator schema. 
 The accumulator schema should be empty and the value schema should be
 the term schema. The apply methods take the value and accumulator Containers
 as input arguments and returns the result container. The result schema is
 <pre><code>
 {key field name, accumulation field(s)}.
 </code></pre>
 This method is called by the MsdxModel.createTermsByRows and 
 MsdxModel.createTermsByColumns methods as part of a multi-Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#add(java.lang.String,java.lang.String)">add</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to combine the accumulation
   container with the item Container to produce the sum expression result Container</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="attach()">attach</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">attach</span>()</div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#attach()">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Attaches sum expressions to constraints and objectives in row orientation or
 to variables in column orientation. Called by a join method, it provides
 an Operator which invokes the solver-specific attachment of expressions to
 modeling objects. It should throw UnsupportedOperationException for
 inapplicable kinds of modeling objects.
 <p>
 The attach Operator performs the following transformation: <br>
 for row orientation --
 <pre><code>
 [rowId, solver expression(sum)] -&gt  
 (join and attach constraints or objectives) [rowId, solver constraint or objective] -&gt  
 [rowId, solver constraint or objective, solver expression] 
 </code></pre>
 for column orientation --
 <pre><code>
 [columnId, solver expression(sum)] -&gt 
 (join and attach variables) [columnId, solver variable] -&gt 
 [columnId, solver variable, solver expression] 
 </code></pre>
 The attach Operator takes as its input arguments two Containers holding
 respectively the accumulation Container holding the sum expression field (or
 fields) to be adjoined and the Container holding a modeling object (constraint or objective in row orientation or
 variable in column orientation). Each pair of Containers is linked by a key field (i.e. the row id or,
 less commonly the column id). 
 It produces a result Container holding the key and the accumulation
 expression and the constraint/objective (or variable) to which the
 accumulation expression is to be attached. (Note that in an optimization
 model, a sum is not a number, but it is a solver-specific object that is
 usually an instance of an expression class representing a sum of terms).
 <p>
 Coding the attach Operator requires defining two components: the
 makeResultSchema method, which specifies the class(es) of the accumulation
 expression(s), and the apply method, which calls the solver-specific methods
 that attaches the accumulation. The result Schema specifies the row or column key
 field, the constraint/objective (or variable) and the expression Schema that
 results from the reduction of the terms using the add operator. The
 apply method takes the modeling object and reduced terms Containers as its
 input arguments and returns the result Container. Note: the result Schema is
 <pre><code>
 {key field name, constraint/objective or variable expressions}.
 </code></pre>
 <p>
 This method is called by the MsdxModel.createTermsByRows and 
 MsdxModel.createTermsByColumns methods as part of a multi-Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#attach()">attach</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an Operator that is used by the Span to attach the accumulation
   Container to the modeling object Container</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">generate</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">generate</span>&#8203;(<span class="arguments"><a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</span></div>
<div class="block">Write a text representation of the model. 
 Usually, the text will use a standard (non-MOSDEX) format, such as .mps or .lp;
 Used, in particular, when the model is not to be solved.
 In this version, the .lp format is used, 
 but you can change the file type of tempFile 
 to .mps, if that is the preferred format.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">generate</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>model</code> - not used in CPLEX</dd>
<dd><code>out</code> - destination for the text</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">solve</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">solve</span>&#8203;(<span class="arguments"><a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">Calls the solver, returns its status, and creates the solver results.
 The solver results are the native output of the solver, 
 not in the the form of a MOSDEX File;
 the solution is also returned in the Collector of Tables in the Model, 
 from which a MOSDEX File or Files are created by the Application.
 If the "solver" does not actually produce a solution 
 (but instead generates, for example, a .lp or .mps representation),
 the status returned should be "Not supported" (case insensitive).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">solve</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dd><code>out</code> - destination for native solver results (null if not needed)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a string containing the status of the solve (e.g. optimal, infeasible, unbounded, etc.)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="initializeFunctionTable(io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">initializeFunctionTable</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</span>&nbsp;<span class="memberName">initializeFunctionTable</span>&#8203;(<span class="arguments"><a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a>&nbsp;dataframeFactory)</span></div>
<div class="block">This method creates an initial set of function entries for the most common 
 solution information produced by a solver. You can add others if you need them, 
 using the steps outlined below.
 
 Optimization solvers can produce a plethora of information about the solution. As this time, MOSDEX supports 
 only the basics: optimal primal value, reduced cost, and basis status of a variable, optimal dual value and slack of a constraint, and 
 the optimal value of the objective function. However, a user, with a little bit of Java programming, can 
 add to this list by taking the following steps.
 - specify the name and argument of the solver call in the MOSDEX Table instance. This is simply a string entered as an item in the record, of the form
   "functionName(argument)" (see the Msdx2FunctionCall documentation). The MOSDEX parser will create a Msdx2FunctionCall instance from this text.
 - In your application program, retrieve the function table from this modeling factory.
 - Create a new entry in this function table by writing a short Java Function and include the solver call in its apply method. 
   See the intializeTable method for details.
 - Make sure you register the function for use in SQL by calling 
   MsdxDataframe.Factory.registerFunctionCall(functionName) when you create the new entry.
 - That's it. MOSDEX will handle the rest.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#initializeFunctionTable(io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">initializeFunctionTable</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dataframeFactory</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function table</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getFunctionTable()">getFunctionTable</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType">java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</span>&nbsp;<span class="memberName">getFunctionTable</span>()</div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#getFunctionTable()">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">The function table is a mapping between the function names, established in the 
 FunctionCall object, and the function implementations as Java Functions.
 The is method presupposes that a function table has been created in the implementing classes 
 of this factory interface.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#getFunctionTable()">getFunctionTable</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function table as a Map</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="retrieveSolution(java.lang.String)">retrieveSolution</a></h3>
<div class="memberSignature"><span class="modifiers">public</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">retrieveSolution</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass)</span></div>
<div class="block"><span class="descfrmTypeLabel">Description copied from interface:&nbsp;<code><a href="MsdxSolverModelingFactory.html#retrieveSolution(java.lang.String)">MsdxSolverModelingFactory</a></code></span></div>
<div class="block">This Operator is used in MsdxModel to retrieve the solution items from the
 solver. The solution items are denoted in a Table Instance Record as those
 with type Msdx2FunctionCall. Their names are not pre-specified in the Record
 Schema (in contrast to the solver modeling objects, which are prescribed by
 MOSDEX) to leave the opportunity for the MOSDEX user to give them her own
 names or to retrieve items of the solution beyond those currently specified,
 as discussed in the initializeFunctionTable method. The set of those function
 field names is created as the schema is processed in withResultSchema method
 of this operator.
 <p>
 Performs the following transformation:
 <pre><code>
 [key field, solver modeling object, other element fields] 
 (join and retrieve) [table name, key field, solver function calls, other record fields] -&gt 
 [table name, key field, solution values, other record fields] 
 </code></pre>
 This method processes each Table Record by joining it to the corresponding
 element of the modeling object bridge, in order to have access to the
 solver-specific components of the element (i.e. variable, constraint, or
 objective). It then gets the function that retrieves the solution item from
 the function table using the function name that is part of the
 Msdx2FunctionCall object of the function field in the table record. It
 applies that function and returns the value of the solution item, which is
 stored in the function field's Msdx2FunctionCall object. It then returns the
 updated table record.
 <p>
 Optimization solvers can produce a plethora of information about the
 solution. As this time, MOSDEX supports only the basics: optimal primal
 value, reduced cost, and basis status of a variable, optimal dual value and
 slack of a constraint, and the optimal value of the objective function. To
 add to this list, see the instructions in the initializeFunctionTable method.
 <p>
 This method is called by the MsdxModel.createSolutionObjects method as part
 of a single Span bridge.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="MsdxSolverModelingFactory.html#retrieveSolution(java.lang.String)">retrieveSolution</a></code>&nbsp;in interface&nbsp;<code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - to which this retrieval applies</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MsdxCplexModelingFactory.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
