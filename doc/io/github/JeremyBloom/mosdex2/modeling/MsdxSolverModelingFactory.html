<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (13) on Mon Aug 08 15:55:32 PDT 2022 -->
<title>MsdxSolverModelingFactory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-08-08">
<meta name="description" content="declaration: package: io.github.JeremyBloom.mosdex2.modeling, interface: MsdxSolverModelingFactory">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../script-dir/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../script-dir/jquery-3.4.1.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.js"></script>
</head>
<body class="class-declaration">
<script type="text/javascript">var data = {"i0":6,"i1":6,"i2":18,"i3":18,"i4":18,"i5":18,"i6":6,"i7":6,"i8":6,"i9":18,"i10":6,"i11":6,"i12":6,"i13":6,"i14":6,"i15":18,"i16":18,"i17":6,"i18":18,"i19":6,"i20":6};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MsdxSolverModelingFactory.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="navListSearch"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.github.JeremyBloom.mosdex2.modeling</a></div>
<h1 title="Interface MsdxSolverModelingFactory" class="title">Interface MsdxSolverModelingFactory</h1>
</div>
<div class="contentContainer">
<section class="description">
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="MsdxCplexModelingFactory.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxCplexModelingFactory</a></code>, <code><a href="MsdxLpTextModelingFactory.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxLpTextModelingFactory</a></code>, <code><a href="MsdxMpsTextModelingFactory.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxMpsTextModelingFactory</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">MsdxSolverModelingFactory</span></pre>
<div class="block">This interface provides the template for creating and using all solver-specific modeling objects,
 Variables, Constraints, Objectives, and Terms. 
 It encapsulates all of the solver-specific classes needed to create, solve, 
 and use an optimization model specified in MOSDEX. 
 Other than in the implementations of this factory for different solvers, 
 the solver-specific APIs are not exposed to MOSDEX.
 <p>
 This interface defines (and in some cases, provides default implementations) 
 of the transformations used to create the bridge from a MOSDEX modeling object Table
 to its presentation as a solver-specific object. These transformations take 
 the form of operators with one or two Container arguments. The operators provide the means 
 to transform the Container and their schemas simultaneously, to prevent inconsistencies between them.</div>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Dr. Jeremy A. Bloom (jeremyblmca@gmail.com) Â©2019 Jeremy A. Bloom</dd>
</dl>
</section>
<section class="summary">
<ul class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<li class="blockList">
<section class="methodSummary"><a id="method.summary">
<!--   -->
</a>
<h2>Method Summary</h2>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="tableTab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="tableTab" onclick="show(4);">Abstract Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t5" class="tableTab" onclick="show(16);">Default Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<thead>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#add(java.lang.String,java.lang.String)">add</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Adds (reduces) Term expressions across the columns (in row orientation) or
 rows (in column orientation).</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#attach()">attach</a></span>()</code></th>
<td class="colLast">
<div class="block">Attaches sum expressions to constraints and objectives in row orientation or
 to variables in column orientation.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>default java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#contraOrientation()">contraOrientation</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>default java.util.Set&lt;java.lang.String&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#creationOrder()">creationOrder</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the order in which the modeling objects are created.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>default <a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#extractParameters(java.lang.String,java.lang.String,java.lang.String,io.github.JeremyBloom.mosdex2.MsdxContainer)">extractParameters</a></span>&#8203;(java.lang.String&nbsp;tableName,
java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType,
<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Class&lt;?&gt;&gt;&nbsp;tableSchema)</code></th>
<td class="colLast">
<div class="block">Extracts the parameters from each Record in a Table.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>default void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,io.github.JeremyBloom.mosdex2.MsdxOutputDestination)">generate</a></span>&#8203;(<a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
<a href="../MsdxOutputDestination.html" title="class in io.github.JeremyBloom.mosdex2">MsdxOutputDestination</a>&nbsp;out)</code></th>
<td class="colLast">
<div class="block">Write a text representation of the model.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">generate</a></span>&#8203;(<a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</code></th>
<td class="colLast">
<div class="block">Write a text representation of the model.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getFunctionTable()">getFunctionTable</a></span>()</code></th>
<td class="colLast">
<div class="block">The function table is a mapping between the function names, established in the 
 FunctionCall object, and the function implementations as Java Functions.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#getName()">getName</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>default java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initializeFunctionTable(io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">initializeFunctionTable</a></span>&#8203;(<a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a>&nbsp;dataframeFactory)</code></th>
<td class="colLast">
<div class="block">This method creates an initial set of function entries for the most common 
 solution information produced by a solver.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeConstraint(java.lang.String,java.lang.String)">makeConstraint</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific constraint object.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeObjective(java.lang.String,java.lang.String)">makeObjective</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific objective object.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeVariable(java.lang.String,java.lang.String)">makeVariable</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific variable object.</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#multiply(java.lang.String,java.lang.String)">multiply</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Builds a solver-specific expression object by computing a solver-specific
 product of a coefficient and one or two modeling objects.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#orientation()">orientation</a></span>()</code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor" id="i15">
<td class="colFirst"><code>default <a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parameterDefaults(java.lang.String,java.lang.String)">parameterDefaults</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Sets default values for certain missing parameter fields.</div>
</td>
</tr>
<tr class="altColor" id="i16">
<td class="colFirst"><code>default java.util.Set&lt;java.lang.String&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#parameterFields(java.lang.String,java.lang.String)">parameterFields</a></span>&#8203;(java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</code></th>
<td class="colLast">
<div class="block">Specifies the names of the parameter fields for each type of MOSDEX modeling object.</div>
</td>
</tr>
<tr class="rowColor" id="i17">
<td class="colFirst"><code><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#retrieveSolution(java.lang.String)">retrieveSolution</a></span>&#8203;(java.lang.String&nbsp;tableClass)</code></th>
<td class="colLast">
<div class="block">This Operator is used in MsdxModel to retrieve the solution items from the
 solver.</div>
</td>
</tr>
<tr class="altColor" id="i18">
<td class="colFirst"><code>default java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,io.github.JeremyBloom.mosdex2.MsdxOutputDestination)">solve</a></span>&#8203;(<a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
<a href="../MsdxOutputDestination.html" title="class in io.github.JeremyBloom.mosdex2">MsdxOutputDestination</a>&nbsp;out)</code></th>
<td class="colLast">
<div class="block">Calls the solver, returns its status, and creates the solver results.</div>
</td>
</tr>
<tr class="rowColor" id="i19">
<td class="colFirst"><code>java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">solve</a></span>&#8203;(<a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</code></th>
<td class="colLast">
<div class="block">Calls the solver, returns its status, and creates the solver results.</div>
</td>
</tr>
<tr class="altColor" id="i20">
<td class="colFirst"><code><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withName(java.lang.String)">withName</a></span>&#8203;(java.lang.String&nbsp;modelName)</code></th>
<td class="colLast">
<div class="block">Sets the name of the model created by this factory.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<li class="blockList">
<section class="methodDetails"><a id="method.detail">
<!--   -->
</a>
<h2>Method Details</h2>
<ul class="blockList">
<li class="blockList">
<section class="detail">
<h3><a id="orientation()">orientation</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">orientation</span>()</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the orientation, either "Row" or "Column".
 The orientation should be set in the constructor and 
 should be the same for all modeling objects created by the factory.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="contraOrientation()">contraOrientation</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">contraOrientation</span>()</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the opposite of the orientation, either "Column" for row orientation 
 or "Row" for column orientation.
 The orientation should be set in the constructor and 
 should be the same for all modeling objects created by the factory.</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="creationOrder()">creationOrder</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.Set&lt;java.lang.String&gt;</span>&nbsp;<span class="memberName">creationOrder</span>()</div>
<div class="block">Returns the order in which the modeling objects are created.
 In general, MOSDEX Terms cannot be read to create solver expressions until both the 
 solver variables, solver constraints, and solver objectives involved 
 in the expression have been created. However, the order differs for row- or column-orientation: 
 in row orientation variables are created before constraints and objectives, 
 while the reverse is true for column-orientation.
 <p>
 Note, that aside from this general consideration, the query resolver will assure that 
 no table is used before its dependent tables have been resolved.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the creation order</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getName()">getName</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">getName</span>()</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the name of the model created by this factory; 
 you should create an instance field to hold the name</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="withName(java.lang.String)">withName</a></h3>
<div class="memberSignature"><span class="returnType"><a href="MsdxSolverModelingFactory.html" title="interface in io.github.JeremyBloom.mosdex2.modeling">MsdxSolverModelingFactory</a></span>&nbsp;<span class="memberName">withName</span>&#8203;(<span class="arguments">java.lang.String&nbsp;modelName)</span></div>
<div class="block">Sets the name of the model created by this factory.
 You should create a instance field to hold the name.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>modelName</code> - TODO</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>this factory</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="extractParameters(java.lang.String,java.lang.String,java.lang.String,io.github.JeremyBloom.mosdex2.MsdxContainer)">extractParameters</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">extractParameters</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableName,
java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType,
<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Class&lt;?&gt;&gt;&nbsp;tableSchema)</span></div>
<div class="block">Extracts the parameters from each Record in a Table. Sets default values for missing parameters.
 Performs the following transformation:
 <pre><code>
 MOSDEX table record -&gt (extractParameters) -&gt [parameters...]
 </code></pre>
 Coding the extractParameters operator requires defining two components: the
 makeResultSchema method, which specifies the names and types of the parameters, 
 and the apply method, which filters the input Container to find the parameters and set the defaults.
 <p>
 This method is called by the modeling object creators of this class and 
 serves as the first Span in the sequence of transformations forming the bridge to the solver.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableName</code> - </dd>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dd><code>tableSchema</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that transforms a data Record to a Container of the form <code>[parameters...]</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if any missing parameter has no default value</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeVariable(java.lang.String,java.lang.String)">makeVariable</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">makeVariable</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Builds a solver-specific variable object.
 The underlying operator encapsulates all of the components required to build a variable object.
 <p>
 Performs the following transformation:
 <pre><code>
 [VARIABLE table parameters...] -&gt (makeVariable)  -&gt [solver variables...]
 </code></pre>
 Note that in the diagram above, the end point of each row represents a Span and 
 the transformation is denoted by the operator in parentheses.
 <p>
 Coding the makeVariable operator requires defining two components: the
 makeResultSchema method, which specifies the solver-specific variable class, 
 and the apply method, which creates the variable from the parameters.
 <p>
 This method is called by the MsdxModel.createVariable method as part of a two Span bridge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters to a Container holding a solver-specific variable</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeConstraint(java.lang.String,java.lang.String)">makeConstraint</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">makeConstraint</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Builds a solver-specific constraint object.
 The underlying operator encapsulates all of the components required to build a constraint object.
 <p>
 Performs the following transformation:
 <pre><code>
 [CONSTRAINT parameters...] -&gt (makeConstraint)  -&gt [solver constraints...]
 </code></pre>        
 Note that in the diagram above, the end point of each row represents a span and 
 the transformation is denoted by the operator in parentheses.
 <p>
 Coding the makeConstraint operator requires defining two components: the
 makeResultSchema method, which specifies the solver-specific constraint class, 
 and the apply method, which creates the constraint from the parameters.
 <p>
 This method is called by the MsdxModel.createConstraint method as part of a two Span bridge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters to a Container holding a solver-specific constraint</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="makeObjective(java.lang.String,java.lang.String)">makeObjective</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithOneArgument.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithOneArgument</a></span>&nbsp;<span class="memberName">makeObjective</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Builds a solver-specific objective object.
 The underlying operator encapsulates all of the components required to build an objective object.
 <p>
 Performs the following transformation:
 <pre><code>
 [OBJECTIVE parameters...] -&gt (makeObjective)  -&gt [solver objectives...]
 </code></pre>        
 Note that in the diagram above, the end point of each row represents a span and 
 the transformation is denoted by the operator in parentheses.
 <p>
 Coding the makeObjective operator requires defining two components: the
 makeResultSchema method, which specifies the solver-specific objective class, 
 and the apply method, which creates the objective from the parameters.
 <p>
 This method is called by the MsdxModel.createObjective method as part of a two Span bridge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters to a Container holding a solver-specific objective</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="multiply(java.lang.String,java.lang.String)">multiply</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">multiply</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Builds a solver-specific expression object by computing a solver-specific
 product of a coefficient and one or two modeling objects. The underlying
 operator encapsulates all of the components required to build a Term object.
 Called by a join operation which combines the Term parameters with the
 Variables in a Row orientation, where it creates either linear or quadratic
 terms, or with the Constraints and Objectives in a Column orientation, where
 only linear terms are allowed.
 <p>
 If the Term is of type LINEAR, the multiply operator is applied once for the
 product of a coefficient with a Variable; if the Term is of type QUADRATIC,
 it is applied following a standard merge join with the first Variable for the
 product of a coefficient with two Variables.
 <p>
 Performs the following transformation:<br>
 In Row Orientation - 
 <pre><code>
 [rowId, columnId, coefficient] {if LINEAR} (join and multiply) [columnId, solver variable ] -&gt 
 [rowId, columnId, solver expression(coefficient * variable object)]
 or 
 [rowId, columnId, coefficient] {if QUADRATIC} -&gt  (join) [columnId, solver variable ] -&gt 
 (join and multiply) [columnId2, solver variable2] -&gt [rowId, solver expression(coefficient * solver variable * solver variable2)] 
 </code></pre>
 In Column Orientation - 
 <pre><code>
 [columnId, rowId, coefficient] -&gt (join and multiply) [rowId, constraint or objective object] -&gt 
 [columnId, rowId, expression(coefficient)] 
 </code></pre>
 The multiply operator takes as its input arguments two Containers holding
 respectively the coefficient and modeling object, each also having the key (i.e. the column id or,
 less commonly the row id). It produces a result container holding the key
 and the expression object representing the product. (Note that in an optimization model, a product is
 not a number, but it is a solver-specific object that is usually an instance
 of an expression class).
 <p>
 Coding the multiply operator requires defining two components: the
 makeResultSchema method, which specifies the class of the product 
 expression, and the apply methods (onKeyMatch and noKeyMatch), which call
 the solver-specific method that computes the product.
 <p>
 This method is called by the MsdxModel.createTermsByRows and 
 MsdxModel.createTermsByColumns methods as part of a multi-Span bridge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to transform the parameters and
         solver modeling object to a Container holding a solver-specific product expression</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="add(java.lang.String,java.lang.String)">add</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">add</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Adds (reduces) Term expressions across the columns (in row orientation) or
 rows (in column orientation). Called by a reduce method, it provides an operator 
 which invokes the solver-specific sum of terms. 
 It should throw UnsupportedOperationException for inapplicable kinds of modeling objects.
 <p>
 The add operator performs the following transformation: <br>
 For row orientation --
 <pre><code>
 [rowId, columnId, solver term] -&gt  (add across columnIds) [rowId, solver expression(sum)]
 </code></pre>
 For column orientation --
 <pre><code>
 [rowId, columnId, solver term] -&gt  (add across rowIds) [columnId, solver expression(sum)]
 </code></pre>
 The add operator takes as its input arguments two containers holding
 respectively the value field or fields representing the terms to be
 adjoined to the accumulation and the accumulation field (or fields) representing the sum
 expression, each also having the key (i.e. the row id or,
 less commonly the column id). The add operator is used to add the individual
 terms to the sum expression. It produces a result container holding the key
 and the accumulation objects. (Note that in an optimization model, a sum is
 not a number, but it is a solver-specific object that is usually an instance
 of an expression class representing a sum of terms).
 <p>
 Coding the add operator requires defining two components: the
 makeResultSchema method, which specifies the class(es) of the accumulation
 expression(s), and the apply methods (onKeyMatch and noKeyMatch), which call
 the solver-specific methods that computes the sum. The result schema merges 
 the value schema with the key and accumulation fields of the accumulator schema. 
 The accumulator schema should be empty and the value schema should be
 the term schema. The apply methods take the value and accumulator Containers
 as input arguments and returns the result container. The result schema is
 <pre><code>
 {key field name, accumulation field(s)}.
 </code></pre>
 This method is called by the MsdxModel.createTermsByRows and 
 MsdxModel.createTermsByColumns methods as part of a multi-Span bridge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an operator that is used by the Span to combine the accumulation
   container with the item Container to produce the sum expression result Container</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="attach()">attach</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">attach</span>()</div>
<div class="block">Attaches sum expressions to constraints and objectives in row orientation or
 to variables in column orientation. Called by a join method, it provides
 an Operator which invokes the solver-specific attachment of expressions to
 modeling objects. It should throw UnsupportedOperationException for
 inapplicable kinds of modeling objects.
 <p>
 The attach Operator performs the following transformation: <br>
 for row orientation --
 <pre><code>
 [rowId, solver expression(sum)] -&gt  
 (join and attach constraints or objectives) [rowId, solver constraint or objective] -&gt  
 [rowId, solver constraint or objective, solver expression] 
 </code></pre>
 for column orientation --
 <pre><code>
 [columnId, solver expression(sum)] -&gt 
 (join and attach variables) [columnId, solver variable] -&gt 
 [columnId, solver variable, solver expression] 
 </code></pre>
 The attach Operator takes as its input arguments two Containers holding
 respectively the accumulation Container holding the sum expression field (or
 fields) to be adjoined and the Container holding a modeling object (constraint or objective in row orientation or
 variable in column orientation). Each pair of Containers is linked by a key field (i.e. the row id or,
 less commonly the column id). 
 It produces a result Container holding the key and the accumulation
 expression and the constraint/objective (or variable) to which the
 accumulation expression is to be attached. (Note that in an optimization
 model, a sum is not a number, but it is a solver-specific object that is
 usually an instance of an expression class representing a sum of terms).
 <p>
 Coding the attach Operator requires defining two components: the
 makeResultSchema method, which specifies the class(es) of the accumulation
 expression(s), and the apply method, which calls the solver-specific methods
 that attaches the accumulation. The result Schema specifies the row or column key
 field, the constraint/objective (or variable) and the expression Schema that
 results from the reduction of the terms using the add operator. The
 apply method takes the modeling object and reduced terms Containers as its
 input arguments and returns the result Container. Note: the result Schema is
 <pre><code>
 {key field name, constraint/objective or variable expressions}.
 </code></pre>
 <p>
 This method is called by the MsdxModel.createTermsByRows and 
 MsdxModel.createTermsByColumns methods as part of a multi-Span bridge.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an Operator that is used by the Span to attach the accumulation
   Container to the modeling object Container</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">generate</a></h3>
<div class="memberSignature"><span class="returnType">void</span>&nbsp;<span class="memberName">generate</span>&#8203;(<span class="arguments"><a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</span></div>
<div class="block">Write a text representation of the model. 
 Usually, the text will use a standard (non-MOSDEX) format, such as .mps or .lp;
 Used, in particular, when the model is not to be solved.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>model</code> - </dd>
<dd><code>out</code> - destination for the text (no output if null)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="generate(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,io.github.JeremyBloom.mosdex2.MsdxOutputDestination)">generate</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">void</span>&nbsp;<span class="memberName">generate</span>&#8203;(<span class="arguments"><a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
<a href="../MsdxOutputDestination.html" title="class in io.github.JeremyBloom.mosdex2">MsdxOutputDestination</a>&nbsp;out)</span></div>
<div class="block">Write a text representation of the model. 
 Usually, the text will use a standard (non-MOSDEX) format, such as .mps or .lp;
 Used, in particular, when the model is not to be solved.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>model</code> - </dd>
<dd><code>out</code> - destination for the text (no output if null)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,java.io.PrintStream)">solve</a></h3>
<div class="memberSignature"><span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">solve</span>&#8203;(<span class="arguments"><a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
java.io.PrintStream&nbsp;out)</span></div>
<div class="block">Calls the solver, returns its status, and creates the solver results.
 The solver results are the native output of the solver, 
 not in the the form of a MOSDEX File;
 the solution is also returned in the Collector of Tables in the Model, 
 from which a MOSDEX File or Files are created by the Application.
 If the "solver" does not actually produce a solution 
 (but instead generates, for example, a .lp or .mps representation),
 the status returned should be "Not supported" (case insensitive).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>model</code> - </dd>
<dd><code>out</code> - destination for native solver results (null if not needed)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a string containing the status of the solve (e.g. optimal, infeasible, unbounded, etc.)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="solve(io.github.JeremyBloom.mosdex2.modeling.MsdxModel,io.github.JeremyBloom.mosdex2.MsdxOutputDestination)">solve</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.lang.String</span>&nbsp;<span class="memberName">solve</span>&#8203;(<span class="arguments"><a href="MsdxModel.html" title="class in io.github.JeremyBloom.mosdex2.modeling">MsdxModel</a>&nbsp;model,
<a href="../MsdxOutputDestination.html" title="class in io.github.JeremyBloom.mosdex2">MsdxOutputDestination</a>&nbsp;out)</span></div>
<div class="block">Calls the solver, returns its status, and creates the solver results.
 The solver results are the native output of the solver, 
 not in the the form of a MOSDEX File;
 the solution is also returned in the Collector of Tables in the Model, 
 from which a MOSDEX File or Files are created by the Application.
 If the "solver" does not actually produce a solution 
 (but instead generates, for example, a .lp or .mps representation),
 the status returned should be "Not supported" (case insensitive).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>model</code> - </dd>
<dd><code>out</code> - destination for native solver results (null if not needed)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a string containing the status of the solve (e.g. optimal, infeasible, unbounded, etc.)</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="getFunctionTable()">getFunctionTable</a></h3>
<div class="memberSignature"><span class="returnType">java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</span>&nbsp;<span class="memberName">getFunctionTable</span>()</div>
<div class="block">The function table is a mapping between the function names, established in the 
 FunctionCall object, and the function implementations as Java Functions.
 The is method presupposes that a function table has been created in the implementing classes 
 of this factory interface.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function table as a Map</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="initializeFunctionTable(io.github.JeremyBloom.mosdex2.dataframe.MsdxDataframe.Factory)">initializeFunctionTable</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.Map&lt;java.lang.String,&#8203;java.util.function.Function&lt;<a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;,&#8203;?&gt;&gt;</span>&nbsp;<span class="memberName">initializeFunctionTable</span>&#8203;(<span class="arguments"><a href="../dataframe/MsdxDataframe.Factory.html" title="interface in io.github.JeremyBloom.mosdex2.dataframe">MsdxDataframe.Factory</a>&nbsp;dataframeFactory)</span></div>
<div class="block">This method creates an initial set of function entries for the most common 
 solution information produced by a solver. You can add others if you need them, 
 using the steps outlined below.
 <p>
 Optimization solvers can produce a plethora of information about the solution. As this time, MOSDEX supports 
 only the basics: optimal primal value, reduced cost, and basis status of a variable, optimal dual value and slack of a constraint, and 
 the optimal value of the objective function. However, a user, with a little bit of Java programming, can 
 add to this list by taking the following steps.
 <ul>
 <li>Define a functionTable field in the solver factory class that implements this interface and 
   initialize it in the constructor by calling the initializeFunctionTable method.</li>
 <li>Specify the name and argument of the solver call in the MOSDEX Table Instance. This is simply a string entered as an item in a Record, 
   of the form "functionName(argument)" (see the Msdx2FunctionCall documentation). 
   The Schema field for the item must have a field type of "xx_FUNCTION", where xx is the return type (e.g. DOUBLE).
   The MOSDEX parser will create a Msdx2FunctionCall instance from this text.</li>
 <li>In your application program, retrieve the function table from this modeling factory.</li>
 <li>Create a new entry in this function table by writing a short Java Function 
   and include the solver call in its apply method. 
   See the intializeFunctionTable implementation in the MsdxCplexModelingFactory for details.</li>
 <li>Make sure you register the function for use in SQL by calling 
   MsdxDataframe.Factory.registerFunctionCall(functionName) when you create the new entry.</li>
 <li>That's it. MOSDEX will handle the rest.</li>
</ul> 
 The default method simply defines the function calls as SQL user-defined functions that produce 
 the appropriate call strings. Override the default to add calls to the solver-specific methods that  
 retrieve values from the solution.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>dataframeFactory</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the function table as a Map</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="retrieveSolution(java.lang.String)">retrieveSolution</a></h3>
<div class="memberSignature"><span class="returnType"><a href="../span/OperatorWithTwoArguments.html" title="class in io.github.JeremyBloom.mosdex2.span">OperatorWithTwoArguments</a></span>&nbsp;<span class="memberName">retrieveSolution</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass)</span></div>
<div class="block">This Operator is used in MsdxModel to retrieve the solution items from the
 solver. The solution items are denoted in a Table Instance Record as those
 with type Msdx2FunctionCall. Their names are not pre-specified in the Record
 Schema (in contrast to the solver modeling objects, which are prescribed by
 MOSDEX) to leave the opportunity for the MOSDEX user to give them her own
 names or to retrieve items of the solution beyond those currently specified,
 as discussed in the initializeFunctionTable method. The set of those function
 field names is created as the schema is processed in withResultSchema method
 of this operator.
 <p>
 Performs the following transformation:
 <pre><code>
 [key field, solver modeling object, other element fields] 
 (join and retrieve) [table name, key field, solver function calls, other record fields] -&gt 
 [table name, key field, solution values, other record fields] 
 </code></pre>
 This method processes each Table Record by joining it to the corresponding
 element of the modeling object bridge, in order to have access to the
 solver-specific components of the element (i.e. variable, constraint, or
 objective). It then gets the function that retrieves the solution item from
 the function table using the function name that is part of the
 Msdx2FunctionCall object of the function field in the table record. It
 applies that function and returns the value of the solution item, which is
 stored in the function field's Msdx2FunctionCall object. It then returns the
 updated table record.
 <p>
 Optimization solvers can produce a plethora of information about the
 solution. As this time, MOSDEX supports only the basics: optimal primal
 value, reduced cost, and basis status of a variable, optimal dual value and
 slack of a constraint, and the optimal value of the objective function. To
 add to this list, see the instructions in the initializeFunctionTable method.
 <p>
 This method is called by the MsdxModel.createSolutionObjects method as part
 of a single Span bridge.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - to which this retrieval applies</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="parameterFields(java.lang.String,java.lang.String)">parameterFields</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType">java.util.Set&lt;java.lang.String&gt;</span>&nbsp;<span class="memberName">parameterFields</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Specifies the names of the parameter fields for each type of MOSDEX modeling object. 
 While the table will probably include other fields, these are essential, 
 although some may have default values. If a required parameter field is missing, 
 and does not have a default value, an exception will be thrown by the extractParameters call.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>names of the parameter fields</dd>
</dl>
</section>
</li>
<li class="blockList">
<section class="detail">
<h3><a id="parameterDefaults(java.lang.String,java.lang.String)">parameterDefaults</a></h3>
<div class="memberSignature"><span class="modifiers">default</span>&nbsp;<span class="returnType"><a href="../MsdxContainer.html" title="class in io.github.JeremyBloom.mosdex2">MsdxContainer</a>&lt;java.lang.Object&gt;</span>&nbsp;<span class="memberName">parameterDefaults</span>&#8203;(<span class="arguments">java.lang.String&nbsp;tableClass,
java.lang.String&nbsp;tableType)</span></div>
<div class="block">Sets default values for certain missing parameter fields.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>tableClass</code> - </dd>
<dd><code>tableType</code> - </dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>default values</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MsdxSolverModelingFactory.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
