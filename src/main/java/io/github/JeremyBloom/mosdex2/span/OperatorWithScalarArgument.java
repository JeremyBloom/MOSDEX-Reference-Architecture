package io.github.JeremyBloom.mosdex2.span;

import java.util.function.Consumer;
import java.util.function.Function;

import io.github.JeremyBloom.mosdex2.MsdxContainer;

/**
	 * Not used in MOSDEX. 
	 * A functional analog of Supplier, which generates a result each time it is called and allows for a scalar (not a Span) input.
	 * 
	 * There are two abstract methods that need to be specified:
	 * 
	 * OperatorWithScalarArgument withResultSchema() {
	 *   if(this.resultSchema != null)
	 *     throw new IllegalStateException("Result schema has already been defined");
	 *   this.resultSchema= BasicContainer.<Class<?>>builder()
	 *     // The schema definition goes here.
	 *     .build();
	 *   return this;
	 * }//withResultSchema
	 *
	 * MsdxContainer<Object> apply(Object t) {
	 *   return Msdx2Span.buildContainer(this.getResultSchema())
	 *     // The result computation goes here.
	 *     .build();
	 * }//apply
	 * 
	 * @author Dr. Jeremy A. Bloom (jeremyblmca@gmail.com) Â©2019 Jeremy A. Bloom
	 *
	 */
	@Deprecated
	public abstract class OperatorWithScalarArgument /* extends Function<Object, MsdxContainer<Object>> */ {

		protected MsdxContainer<Class<?>> resultSchema;

		public OperatorWithScalarArgument() {
			super();
			this.resultSchema = null;
		}
		
		/**
		 * Specifies the schema of the result containers.
		 * 
		 * @return
		 */
		public abstract OperatorWithScalarArgument withResultSchema();
			// The schema definition goes here.

		public MsdxContainer<Class<?>> getResultSchema() {
			if(this.resultSchema == null)
				throw new IllegalStateException("Result schema has not been defined");
			return this.resultSchema;
		}
		
		/**
		 * Computes the result container.
		 * 
		 * @param t input parameter
		 * @return
		 * @throws IllegalArgumentException if the result container is inconsistent with the result schema 
		 * (i.e. missing or extra fields or type mismatch on any field)
		 */
		public abstract MsdxContainer<Object> apply(Object t);
			// The input to result transformation goes here.
	
		/**
		 * Returns the result records generated by this operator, 
		 * additionally performing the provided action on each record 
		 * as those records are consumed.
		 * 
		 * Usage:
		 * 	 OperatorWithTwoArguments combiner= ...;
		 *   terms.leftOuterJoin(variables, "Column", combiner)
		 *     .map(combiner.peek(record -> System.out(record.get(keyFieldName).toString));
		 *     
		 * Note: this directive is not executed until a terminal operation is performed on this span.
		 *  
		 * @param consumer specifies the action to be performed as the records are returned
		 * @return
		 */
		public OperatorWithOneArgument peek(Consumer<MsdxContainer<Object>> consumer) {
			
			OperatorWithOneArgument peek= new OperatorWithOneArgument() {

				@Override
				public OperatorWithOneArgument withResultSchema(MsdxContainer<Class<?>> inputSchema) {
					this.resultSchema= inputSchema;
					return this;
				}//withResultSchema

				@Override
				public MsdxContainer<Object> apply(MsdxContainer<Object> record) {
					consumer.accept(record);
					return record;
				}//apply
				
			};//OperatorWithOneArgument
			 
			return peek.withResultSchema(this.getResultSchema());
		}//peek
		
		static OperatorWithScalarArgument fromLambda(
				Function<Object, MsdxContainer<Object>> function, 
				MsdxContainer.Builder<Class<?>> schema) 
			{
				return new OperatorWithScalarArgument() {

					@Override
					public OperatorWithScalarArgument withResultSchema() {
						 this.resultSchema= schema.build();
						 return this;
					}//withResultSchema

					@Override
					public MsdxContainer<Object> apply(Object t) {
						return function.apply(t);
					}//apply

				}/*OperatorWithOneArgument*/;//return
			}//fromLambda
				
	}//class Msdx2Span.OperatorWithScalarArgument